## 继续巩固学习demo

在添加新功能时，步骤如下（web--usr--sim）：

1. 创建新的页面sumsim.html，使用Ajax将数据传给web，并通过url指定一个交易sumSim

   ```javascript
   var url = "http://"+host+"/web/sumSim.do";
   ```
   ```javascript
   $.ajax({
        type: "POST",
        url: document.forms[0].postURL.value,
        contentType: "application/json; charset=utf-8",
        data: document.forms[0].sendMessage.value,
        dataType: "json",
        success: function (message) {
        	outJson.set(message);
        },
        error: function (message) {
        	outJson.set(message);
        }
    });
   ```

2. 在交易的配置文件中创建新的交易sumSim，同时为这个交易绑定一个Action，并配置这个Action所对应的类

   ```xml
   <transaction id="sumSim" template="publicQueryTemplate">
   		<description>
   		</description>
   		<actions>
   			<ref name="action">SumSimAction</ref>
   		</actions>
   </transaction>
   <action name="SumSimAction" class="com.csii.demo.usr.action.SumSimAction" parent="BaseQueryAction" />
   ```

3. 创建前一步所需要的Action类,Action中通常要干3件事：

   * 从context中获取数据，并和指定的下一个交易名称一起放入map
   * 通过dubbo将map的信息发送给usr，并接受返回值
   * 将获取到的返回数据以json格式存入context

   ```java
   package com.csii.demo.usr.action;
   
   import com.csii.ibs.action.IbsQueryAction;
   import com.csii.pe.core.Context;
   import com.csii.pe.core.PeException;
   
   import java.util.Map;
   
   public class SumSimAction extends IbsQueryAction {
       @SuppressWarnings({"unchecked", "rawtypes"})
       @Override
       public void execute(Context context) throws PeException {
           Map map = context.getDataMap();
           map.put("_HostTransactionCode", "sumSim"); //这个是指交易
           System.out.println("我是web的SumSimAction：" + map);
           Map result = (Map) this.issueHostTrs(context, map);
           context.setData("json", result);
       }
   }
   ```

4. 因为web到usr是使用dubbo连接，所以需要对dubbo进行配置，dubbo有两个配置文件：dubbo-registry.xml（负责注册中心配置，不需要进行修改），dubbo-reference.xml（负责引用服务配置，用于创建一个远程服务代理，一个引用可以指向多个注册中心），需要在此文件中添加配置，对应一个usr的方法

   ```xml
   <dubbo:reference id="UserService" interface="com.csii.demo.usr.api.UserService" timeout="10000" check="false"/>
   <service:transport trsCodeName="_HostTransactionCode" id="transport">
       <service:mapping trsCode="queryUser" method="UserService:queryUser"/>
       <service:mapping trsCode="queryUser001" method="UserService:queryUser001"/>
       <service:mapping trsCode="testSim" method="UserService:testSim"/>
       <service:mapping trsCode="testSim001" method="UserService:testSim001"/>
       <service:mapping trsCode="sumSim" method="UserService:sumSim"/>
   </service:transport>
   ```

   相当于sumSim这个交易对应到UserService接口中的sumSim方法

   在dubbo的另一头，usr上也需要进行dubbo-service.xml（负责服务配置，用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心）的配置，内容与reference略有不同

   ```xml
   <dubbo:service interface="com.csii.demo.usr.api.UserService" ref="UserService" protocol="dubbo"/>
   <service:bridge id="UserService" interface="com.csii.demo.usr.api.UserService">
       <service:mapping method="queryUser" trsCode="queryUser"/>
       <service:mapping method="queryUser001" trsCode="queryUser001"/>
       <service:mapping method="testSim" trsCode="testSim"/>
       <service:mapping method="testSim001" trsCode="testSim001"/>
       <service:mapping method="sumSim" trsCode="sumSim"/>
   </service:bridge>
   ```

5. 根据配置内容，显然还需要定义一个UserService接口

   ```java
   package com.csii.demo.usr.api;
   
   import com.csii.demo.usr.dto.QueryUserRequest;
   import com.csii.demo.usr.dto.QueryUserResponse;
   import com.csii.demo.usr.dto.TestSimRequest;
   import com.csii.demo.usr.dto.TestSimResponse;
   import com.csii.demo.usr.dto.SumSimRequest;
   
   public interface UserService {
       public QueryUserResponse queryUser(QueryUserRequest request);
   
       public QueryUserResponse queryUser001(QueryUserRequest request);
   
       public TestSimResponse testSim(TestSimRequest testSimRequest);
   
       public TestSimResponse testSim001(TestSimRequest testSimRequest);
   
       public TestSimResponse sumSim(SumSimRequest sumSimRequest);
   }
   ```

6. 还需要定义接口中用到的Request类，相应的也要有Response类，它们的作用是接收来自前端的数据和发送返回的数据，**类名需和方法名一致：SumSimRequest、SumSimResponse**

   ```
   package com.csii.demo.usr.dto;
   
   import java.io.Serializable;
   
   public class SumSimRequest implements Serializable {
   
       private static final long serialVersionUID = 8404022192368714234L;
   
       private Integer Param1;
   
       private Integer Param2;
   
       public Integer getParam1() {
           return Param1;
       }
   
       public void setParam1(Integer param1) {
           Param1 = param1;
       }
   
       public Integer getParam2() {
           return Param2;
       }
   
       public void setParam2(Integer param2) {
           Param2 = param2;
       }
   }
   ```
   
   ```java
   package com.csii.demo.usr.dto;
   
   import java.io.Serializable;
   
   public class SumSimResponse implements Serializable {
   
       private static final long serialVersionUID = 3146621319012671335L;
       
       private String resultParam;
   
       public String getResultParam() {
           return resultParam;
       }
   
       public void setResultParam(String resultParam) {
           this.resultParam = resultParam;
       }
   }
   ```
   
7. 交易配置文件中配置其相对应的交易，同时绑定Action

   ```xml
   <transaction id="sumSim" template="publicQueryTemplate">
       <description>
       </description>
       <actions>
           <ref name="action">SumSimAction</ref>
       </actions>
   </transaction>
   <action name="SumSimAction" class="com.csii.demo.usr.action.SumSimAction">
       <ref name="transport">TransformTransport</ref>
   </action>
   ```

8. 创建交易中绑定的SumSimAction类

   ```java
   package com.csii.demo.usr.action;
   
   import com.csii.pe.action.AbstractExecutableAction;
   import com.csii.pe.core.Context;
   import com.csii.pe.core.PeException;
   import com.csii.pe.service.comm.Transport;
   
   import java.util.Map;
   
   public class SumSimAction extends AbstractExecutableAction {
   
       private static Transport transport;
       @SuppressWarnings("unused")
       @Override
       public void execute(Context context) throws PeException {
           Integer param1 = context.getInteger("Param1");
           Integer param2 = context.getInteger("Param2"); //此处不能修改，修改了就获取不到传过来的数据，因为对应的是json格式里的键
   
           System.out.println("我是usr的SumSimAction");
           System.out.println(context);
           System.out.println(param1);
           System.out.println(param2);
   
           Map param = context.getDataMap();
           System.out.println(param);
           param.put("_HostTransactionCode", "SumSim");
           Map<String, Object> retMap = (Map<String, Object>) transport.submit(param);
   
           context.setData("ResultParam", retMap.get("ResultParam"));
       }
   
       public static Transport getTransport() {
           return transport;
       }
   
       public static void setTransport(Transport transport) {
           SumSimAction.transport = transport;
       }
   }
   ```

   这个Action同样做了3件事：

   * 接收从web传过来的数据，并和交易名称一起存入Map类中
   * 通过TCP和sim进行连接，将数据传输过去并接收返回值
   * 将返回数据存入context返回给web

9. usr--sim使用TCP连接，需配置3个文件

   * pe-transform（数据怎么打包、不需要修改）

   ```xml
   <bean name="CXMLTransformerFactory" class="com.csii.pe.transform.XmlTransformerFactory">
       <param name="path">/pe/cxml</param>
       <param name="debug">true</param>
       <param name="cacheEnable">true</param>
       <map name="parsers">
           <ref name="pCXMLPacketParser">CXMLPacketParser</ref>
       </map>
   </bean>
   <bean name="CXMLPacketParser" class="com.csii.pe.transform.stream.xml.XmlStreamParser">
       <param name="debug">true</param>
       <param name="usingRLCL">true</param>
       <param name="tagTypeClassMapping">/pe/cxml/xmltagtypemapping.properties</param>
       <param name="tagClassMapping">/pe/cxml/xmltagmapping.properties</param>
       <param name="tagAliasMapping">/pe/cxml/xmlaliasmapping.properties</param>
   </bean>
   ```

   * pe-transport（数据怎么发送、不需要修改）

   ```xml
   <config>
       <!-- XMLTransPort 定义 -->
       <transport id="TransformTransport"
                  class="com.csii.pe.service.comm.transport.TransformTransport">
           <ref name="transformerFactory">CXMLTransformerFactory</ref>
           <ref name="transport">Transport</ref>
           <param name="formatName">cxmlPacketFormat</param>
           <param name="parseName">pCXMLPacketParser</param>
           <param name="debug">true</param>
           <param name="dumpPath">/demo</param>
           <ref name="headFormatter">CSHeadFormatter</ref>
           <param name="singleLogFile">true</param> <!-- 在debug为true时,报文日志是否以单文件输出 -->
       </transport>
       <transport id="Transport"
                  class="com.csii.pe.service.comm.tcp.SimpleXMLTcpTransport">
           <param name="host">127.0.0.1</param>
           <param name="port">19001</param>
           <param name="timeout">240000</param>
           <param name="endTagName">Message</param>
           <param name="uibs">true</param>
       </transport>
       <bean id="CSHeadFormatter" class="com.csii.demo.usr.transformer.CSHeadFormatter" />
   </config>
   ```

   * fsegSumSim（制作报文、需要新建，不同的交易对应不同的配置文件）

   ```xml
   <segment>
       <xmlTag>
           <String name="Param1"></String>
       </xmlTag>
       <xmlTag>
           <String name="Param2"></String>
       </xmlTag>
   </segment>
   ```

10. 接下来就到了sim这边，同样配置transform.xml，起作用相当于解封数据

    ```xml
    <config>
        <bean name="TransformerFactory" class="com.csii.pe.transform.XmlTransformerFactory">
            <param name="path">/META-INF/cxml</param>
            <param name="debug">true</param>
            <param name="cacheEnable">false</param>
            <map name="parsers">
                <ref name="xmlPacketParser">xmlPacketParser</ref>
            </map>
        </bean>
        <bean name="xmlPacketParser" class="com.csii.pe.transform.stream.xml.XmlStreamParser">
            <param name="debug">true</param>
            <param name="usingRLCL">true</param>
            <param name="tagClassMapping">/META-INF/cxml/xmltagmapping.properties</param>
            <param name="tagAliasMapping">/META-INF/cxml/xmlaliasmapping.properties</param>
        </bean>
    </config>
    ```
    
11. 根据usr发送过来的数据，指向了SumSim交易，进行配置并绑定Action

    ```xml
    <transaction id="SumSim" template="executableSequenceTemplate">
        <actions>
            <ref name="action">SumSimAction</ref>
        </actions>
    </transaction>
    <action id="SumSimAction" class="com.csii.demo.sim.action.SumSimAction" />
    ```

12. 创建定义SumSimAction类，同样需要完成3件事：

    * 接收从usr过来的context中的数据
    * 对数据进行操作，完成任务
    * 将得到的结果存入context为ResultParam，返回给usr

13. 因为是TCP，所以返回也需要将结果制作成报文，配置文件fsegSumSim.xml

    ```xml
    <xmlTag>
        <String name="ResultParam"></String>
    </xmlTag>
    ```



## Dubbo的配置

| 标签              | 用途 | 解释 |
| :-: | :--: | :--: |
| dubbo:service     | 服务配置 | 用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心 |
| dubbo:reference   | 引用配置 | 用于创建一个远程服务代理，一个引用可以指向多个注册中心 |
| dubbo:protocol    | 协议配置 | 用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受 |
| dubbo:application | 应用配置 | 用于配置当前应用信息，不管该应用是提供者还是消费者 |
| dubbo:module      | 模块配置 | 用于配置当前模块信息，可选 |
| dubbo:registry    | 注册中心配置 | 用于配置连接注册中心相关信息 |
| dubbo:monitor     | 监控中心配置 | 用于配置连接监控中心相关信息，可选 |
| dubbo:provider    | 提供方配置 | 当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选 |
| dubbo:consumer    | 消费方配置 | 当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选 |
| dubbo:method      | 方法配置 | 用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息 |
| dubbo:argument    | 参数配置 | 用于指定方法参数配置 |

